<!DOCTYPE html>
<html>
<head>
    <title>Data Validation</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Sep 10 2015 10:04:39 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Sep 10 2015 10:04:39 GMT-0600 (MDT)";
        var CHECKSUM = 34316408301;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.ValidationRules',{

    ruleFnPrefix: 'ruleFn_',
    requiredFields: undefined,

    constructor: function(config){
        Ext.apply(this, config);
    },

    getRules: function(){
        var ruleFns = [],
            ruleRe = new RegExp('^' + this.ruleFnPrefix);

        for (var fn in this)
        {
            if (ruleRe.test(fn)){
                ruleFns.push(fn);
            }
        }
        return ruleFns;
    },
//    ruleFn_missingFieldsStory: function(r) {
//        var missingFields = [];
//
//        _.each(this.requiredFields, function (f) {
//            if (!r.get(f)) {
//                missingFields.push(f);
//            }
//        });
//        if (missingFields.length === 0) {
//            return null;
//        }
//        return Ext.String.format('Missing fields: {0}', missingFields.join(','));
//    },

    statics: {
        getUserFriendlyRuleLabel: function(ruleName){
            switch(ruleName){
                case 'ruleFn_missingFieldsStory':
                    return '[User Story] Missing required fields';

                case 'ruleFn_missingFieldsFeature':
                    return '[Feature] Missing required fields';

                case 'ruleFn_stateSynchronization':
                    return '[Feature] State is not aligned with story states';

                case 'ruleFn_featureTargetSprintMatchesRelease':
                    return '[Feature] Target Sprint not aligned with Release';

                case 'ruleFn_storiesPlannedByFeatureTargetSprint':
                    return '[Feature] Child stories are planned after Feature Target Sprint';

                case 'ruleFn_featureStateShouldMatchTargetSprint':
                    return '[Feature] State not aligned with Target Sprint';

                case 'ruleFn_unscheduledIterationScheduleState':
                    return '[User Story] In-Progress with unscheduled Iteration';

                case 'ruleFn_blockedFieldsPopulated':
                    return '[User Story] Blocked fields not populated';

                case 'ruleFn_blockedNotInProgress':
                    return '[User Story] Blocked but not In-Progress';

                case 'ruleFn_sprintCompleteNotAccepted':
                    return '[User Story] Past Iteration not complete';
                    
                case 'ruleFn_stateForTargetSprint': 
                    return '[Feature] Past TargetSprint not done';
                case 'ruleFn_featureIsRisk':
                    return '[Feature] is a Risk';
                case 'ruleFn_featureTargetSprintPushed':
                    return '[Feature] Target Sprint was pushed';
                case 'ruleFn_validateCodeDeploymentSchedule':
                    return '[Feature] Code Deployment Schedule not valid';
                case 'ruleFn_featureDisplayColor':
                    return '[Feature] DisplayColor (Risk) not valid' ;
            }
            return ruleName;
        }
    }
});
Ext.define('Rally.technicalservices.Validator',{

    validationRuleObj: undefined,
    records: undefined,

    ruleViolationData: undefined,

    constructor: function(config){
        Ext.apply(this,config);
        this._validate();
    },

    _validate: function(){
        if (this.validationRuleObj && this.records){
            var validationRuleObj = this.validationRuleObj,
                ruleViolationRecords = [],
                totalRecords = 0,
                rules = validationRuleObj.getRules();

            _.each(this.records, function(r){
                totalRecords ++;
                var violations = [];
                _.each(rules, function(rule){
                    var v = validationRuleObj[rule](r);
                    if (v){
                        violations.push({rule: rule, text: v});
                    }
                });

                if (violations.length > 0){
                    ruleViolationRecords.push({
                        ObjectID: r.get('ObjectID'),
                        _ref: r.get('_ref'),
                        FormattedID: r.get('FormattedID'),
                        Name: r.get('Name'),
                        violations: violations,
                        Project: r.get('Project').Name,
                        _type: r.get('_type')
                    });
                }
            });
            this.ruleViolationData = ruleViolationRecords;
        }
    }
});
Ext.define("ts-data-validation", {
    extend: 'Rally.app.TimeboxScopedApp',
    scopeType: 'release',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),

    config: {
        defaultSettings: {
            validCDS: [],
            excludeProjects: []
        }
    },
    /**
     * Configurations
     */
    allReleasesText: 'All Releases',
    portfolioItemFeature: 'PortfolioItem/Feature',
    featureFetchFields: ['PlannedStartDate','PlannedEndDate','FormattedID','Name','Project','Release','c_FeatureDeploymentType','c_FeatureTargetSprint','c_CodeDeploymentSchedule','State','AcceptedLeafStoryCount','LeafStoryCount','DisplayColor'],
    storyFetchFields: ['FormattedID','Name','Project','c_CodeDeploymentSchedule','Iteration','Release','ScheduleState','Feature','Owner','Parent','c_BlockerCategory','c_BlockerOwnerFirstLast','c_BlockerState','Blocked','c_DoDStoryType'],
    iterationFetchFields: ['Name','StartDate','EndDate','State','ObjectID'],
    historicalFeatureFetchFields: ['FormattedID','ObjectID','Project','c_FeatureTargetSprint','_PreviousValues.c_FeatureTargetSprint','Release'],

    featureRequiredFields: ['Release','c_FeatureTargetSprint','c_FeatureDeploymentType','c_CodeDeploymentSchedule','State'],
    storyRequiredFields: ['Release','c_CodeDeploymentSchedule'],
    /**
     * Also in FeatureRisk metrics app
     */
    displayColorClassificationMapping: {
        '#107c1e': 'On Track',
        '#df1a7b': 'High Risk',
        '#fce205': 'Moderate Risk',
        '#f9a814': 'High Risk',
        '#ee6c19': 'High Risk',
        '#848689': 'Not Started',
        '#105cab': 'Completed'
    },

    features: [],
    stories: [],
    iterations: [],
    
    data_collected: false, /* true means we've gotten the stories and features we need */
    
    chartColors: [ '#2f7ed8', '#8bbc21', '#910000',
        '#492970', '#f28f43', '#145499','#77a1e5', '#c42525', '#a6c96a',
        '#7cb5ec', '#434348', '#90ed7d', '#f7a35c', '#8085e9','#aa1925',
        '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1','#1aadce',
        '#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
        '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],

    onTimeboxScopeChange: function(scope) {
    //    this._addReleaseSelector();
        this._addTargetSprintSelector();
        this.gatherData();
    },

    getFeatureRequiredFields: function(){
        return this.featureRequiredFields;
    },
    getStoryRequiredFields: function(){
        return this.storyRequiredFields;
    },
    getIterationFilters: function(){
        var release = this.getContext().getTimeboxScope().getRecord();

        if (release == null || release.get('Name') == this.allReleasesText){
            return [];
        }

        var filters = Rally.data.wsapi.Filter.and([{
            property: 'StartDate',
            operator: '<',
            value: release.get('ReleaseDate')
        },{
            property: 'EndDate',
            operator: '>',
            value: release.get('ReleaseStartDate')
        }]);
        return filters;
    },

    getReleaseFilters: function(){

        var release = this.getContext().getTimeboxScope().getRecord();

        return [{
            property: 'Release.Name',
            value: release.get('Name')
        },{
            property: 'Release.ReleaseStartDate',
            value: release.get('ReleaseStartDate')
        },{
            property: 'Release.ReleaseDate',
            value: release.get('ReleaseDate')
        }];
    },
    //getHistoricalFeatureFindObj: function(){
    //    return {
    //        _TypeHierarchy: this.portfolioItemFeature,
    //        "_PreviousValues.c_FeatureTargetSprint": {$exists: true},
    //        _ValidFrom: {$gte: this.getContext().getTimeboxScope().getRecord().get('ReleaseStartDate')},
    //        _ProjectHierarchy: this.getContext().getProject().ObjectID
    //    };
    //},
    //getHistoricalFeatureFetchFields: function(){
    //    return this.historicalFeatureFetchFields;
    //},
    gatherData: function(){
        this.logger.log('gatherData');
        this.data_collected = false;
        
        this.setLoading(true);
        this.getBody().removeAll();
        
        var promises = [
           // this._fetchHistoricalData(this.getHistoricalFeatureFetchFields(), this.getHistoricalFeatureFindObj()),
            this._fetchData(this.portfolioItemFeature, this.featureFetchFields, this.getReleaseFilters()),
            this._fetchData('HierarchicalRequirement', this.storyFetchFields, this.getReleaseFilters()),
            this._fetchData('Iteration', this.iterationFetchFields, this.getIterationFilters())
        ];

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(results){
                this.setLoading("Analyzing");
                this.logger.log('_fetchData success', results);

                this.features = this._filterOutExcludedProjects(results[0]);
                this.stories = this._filterOutExcludedProjects(results[1]);
                this.iterations = results[2];
                //this.historicalFeatureSnapshots =results[0];
                this.data_collected = true;
                
                this.analyzeData();
            },
            failure: function(operation){
                this.setLoading(false);
                this.logger.log('_fetchData failure', operation);
            }
        });
    },
    
    analyzeData: function() {
        
        if ( !this.data_collected ) {
            this.logger.log("Data Collected: ", this.data_collected);
            return;
        }
        
        console.log('selected target:', this.getSelectedTargetSprint());
        
        var featureRules = Ext.create('Rally.technicalservices.FeatureValidationRules',{
            stories: this.stories,
            iterations: this.iterations,
            targetSprint: this.getSelectedTargetSprint(),
            displayColorClassificationMapping: this.displayColorClassificationMapping,
            //historicalFeatureSnapshots: this.historicalFeatureSnapshots,
            currentRelease: this.getContext().getTimeboxScope().getRecord().get('Name'),
            validCDS: this.getSetting('validCDS')
        });
        
        var featureValidator = Ext.create('Rally.technicalservices.Validator',{
                validationRuleObj: featureRules,
                records: this.features
            });

        var storyRules = Ext.create('Rally.technicalservices.UserStoryValidationRules',{
            iterations: this.iterations
        });
        var storyValidator = Ext.create('Rally.technicalservices.Validator',{
                validationRuleObj: storyRules,
                records: this.stories
            });

        this.validatorData = featureValidator.ruleViolationData.concat(storyValidator.ruleViolationData);
        this._createSummaryHeader(this.validatorData);
        this.setLoading(false);
    }, 
    
    _filterOutExcludedProjects: function(artifacts) {
        var exclude_projects = this.getSetting('excludeProjects');
        var current_project_oid = this.getContext().getProject().ObjectID;
        
        if ( Ext.isEmpty(exclude_projects) ) {
            return artifacts;
        }
        if ( !Ext.isArray(exclude_projects) ) { 
            exclude_projects = exclude_projects.split(','); 
        }
        
        // don't exclude the currently selected project
        var current_project_regex = new RegExp("" + current_project_oid);

        var filtered_exclude_projects = Ext.Array.filter(exclude_projects, function(exclude_project){            
            return ! current_project_regex.test(exclude_project);
        });
                
        var keepers =  Ext.Array.filter(artifacts, function(artifact){
            var keep = true;
            Ext.Array.each(filtered_exclude_projects, function(exclude_project){
                var exclude_project_regex = new RegExp(exclude_project);
                
                if (exclude_project_regex.test(artifact.get('Project')._ref) ){
                    keep = false;
                }

            });
            return keep;
        });
        
        return keepers;
    },
    
    _createSummaryHeader: function(validatorData){
        var ct_chart = this.down('#ct-chart');
        if (!ct_chart){
            var ct_chart = this.getBody().add({
                itemId: 'ct-chart',
                xtype: 'container',
                flex: 1
            });
        }
        this._createSummaryChart(ct_chart, validatorData);

        var ct_detail_grid = this.down('#ct-grid');
        if (!ct_detail_grid){
            var ct_detail_grid = this.getBody().add({
                xtype: 'container',
                itemId: 'ct-grid'
            });
        }
        this._createDetailGrid(ct_detail_grid, validatorData);
    },

    _createSummaryChart: function(ct,validatorData){
        var me = this;
        var dataHash = {}, projects = [], types = [], rules = [];

        _.each(validatorData, function(obj){
            
            if (!_.contains(projects,obj.Project)){
                projects.push(obj.Project);
            }
            if (!_.contains(types, obj._type)){
                types.push(obj._type);
            }
            if (!dataHash[obj.Project]){
                dataHash[obj.Project] = {};
            }
            if (!dataHash[obj.Project][obj._type]){
                dataHash[obj.Project][obj._type] = {};
            }
            _.each(obj.violations, function(v){
                if (!_.contains(rules, v.rule)){
                    rules.push(v.rule);
                }
                dataHash[obj.Project][obj._type][v.rule] = (dataHash[obj.Project][obj._type][v.rule] || 0) + 1;
            });
        });

        projects.sort();

        var series = [];

        var stack_by_type = {
            'project': 'a',
            'iteration': 'a',
            'portfolioitem/feature': 'a',
            'hierarchicalrequirement': 'a',
            'task': 'a' 
        };
        
        _.each(types, function(type){
            _.each(rules, function(r){
                var data = [];
                _.each(projects, function(p){
                    if (dataHash[p] && dataHash[p][type]){
                        data.push(dataHash[p][type][r] || 0);
                    } else {
                        data.push(0);
                    }
                });
                
                series.push({
                    name: Rally.technicalservices.ValidationRules.getUserFriendlyRuleLabel(r),
                    data: data,
                    stack: stack_by_type[type],
                    showInLegend: Ext.Array.sum(data) > 0,
                    events: {
                        click: function(event) {
                            me.logger.log('event:', event);
                            
                            var team = event.point.category;
                            var rule_name = event.point.series.name;
                            me.logger.log('team/rule', team, rule_name);
                                                        
                            var grid = me.down('#detail-grid');
                            grid.getStore().clearFilter(true);
                            
                            grid.getStore().filterBy(function(record){
                                var violations = record.get('violations'),
                                    filter = false;
                                if (violations){
                                    _.each(violations, function(v){
                                        //me.logger.log(v.rule, Rally.technicalservices.ValidationRules.getUserFriendlyRuleLabel(v.rule), v);
                                        //if (v.rule == rule_name || Rally.technicalservices.ValidationRules.getUserFriendlyRuleLabel(v.rule) == rule_name ){
                                        if ( me.last_filter == team ) {
                                            filter = true;
                                        } else if ( team == record.get('Project')) {
                                            filter = true;
                                        }
                                    });
                                }
                                return filter;
                            });

                            me.last_filter = team; // so that a second click unchooses
                        }
                    }
                });
            });
        });

        this.logger.log("Series:", series);
        var categories = Ext.Array.map(projects, function(project) { return _.last(project.split('>')); });
        
        var selectedRelease = this.getContext().getTimeboxScope().getRecord();
        
        var subtitle_text = (selectedRelease ? '<b>' + selectedRelease.get('Name')  + '</b>': 'All Releases');

        if (this.down('#summary-chart')){
            this.down('#summary-chart').destroy();
        }
        var chart = ct.add({
            xtype: 'rallychart',
            itemId: 'summary-chart',
            loadMask: false,
            chartData: {
                series: series,
                categories: categories
            },
            chartConfig: {
                colors: me.chartColors,
                chart: {
                    type: 'bar'
                },
                title: {
                    text: null
                },
               /* subtitle: {
                    text: subtitle_text
                },*/
                legend: {
                    align: 'center',
                    verticalAlign: 'bottom'
                },
                xAxis: {
                    categories: projects
                },
                yAxis: {
                    title: 'Project'
                },
                plotOptions: {
                    series: {
                       stacking: 'normal'
                    }
                }
            }
        });
        ct.setSize(chart.getWidth(), chart.getHeight());
    },
    
    _createDetailGrid: function(ct, violationData){
        ct.removeAll();

        var store = Ext.create('Rally.data.custom.Store',{
            data: violationData,
            pageSize: violationData.length,
            groupField: 'Project',
            groupDir: 'ASC',
            remoteSort: false,
            getGroupString: function(record) {
                return record.get('Project');
            }
        });

        ct.add({
            xtype:'rallygrid',
            store: store,
            itemId: 'detail-grid',
            columnCfgs: this._getColumnCfgs(),
            showPagingToolbar: false,
            features: [{
                ftype: 'groupingsummary',
                groupHeaderTpl: '{name} ({rows.length})',
                startCollapsed: true
            }]
        });
    },
    _getColumnCfgs: function(){
        var me = this;
        return [{
            dataIndex: 'FormattedID',
            text: 'id',
            renderer: function(value,meta_data,record) {
                var url = Rally.nav.Manager.getDetailUrl(record);
                var link = "<a target='_blank' href='" + url + "'>" + value + "</a>";
                
                
                return link;
            }
        },{
            dataIndex: 'violations',
            text: 'Title',
            renderer: this._ruleRenderer,
            flex: 1
        },
        {
            dataIndex: 'violations',
            text:'Issues',
            renderer: this._validatorRenderer,
            flex: 3
        }];
    },
    _ruleRenderer: function(v,m,r){
        var rules = '';
        if (v && v.length > 0){
            _.each(v, function(va){
                var friendly_text = Rally.technicalservices.ValidationRules.getUserFriendlyRuleLabel(va.rule);
                rules += friendly_text + '<br/>';
            });
        }
        return rules;
    },
    _validatorRenderer: function(v,m,r){
        var issues = '';
        if (v && v.length > 0){
            _.each(v, function(va){
                issues += va.text + '<br/>';
            });
        }
        return issues;
    },
    _fetchHistoricalData: function(fetchFields, find){
        var deferred = Ext.create('Deft.Deferred'),
            store = Ext.create('Rally.data.lookback.SnapshotStore',{
                find: find,
                fetch: fetchFields,
                limit: 'Infinity',
                hydrate: ['Project','Release'],
                removeUnauthorizedSnapshots: true,
                compress: true
            });

        store.load({
            scope: this,
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation);
                }
            }
        });
        return deferred;
    },
    _fetchData: function(modelType, fetchFields, filters){

        var deferred = Ext.create('Deft.Deferred'),
            store = Ext.create('Rally.data.wsapi.Store',{
                model: modelType,
                limit: 'Infinity',
                fetch: fetchFields,
                filters: filters
        });

        store.load({
            scope: this,
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation);
                }
            }
        });
        return deferred;
    },

    _addTargetSprintSelector: function() {
        this.logger.log('_addTargetSprintSelector');
        if (this.down('#cb-targetsprint')){
            this.down('#cb-targetsprint').destroy();
        }
        var cb = this.getHeader().add({
            xtype: 'rallyfieldvaluecombobox',
            model: Ext.identityFn('PortfolioItem/Feature'),
            field: 'c_FeatureTargetSprint',
            itemId: 'cb-targetsprint',
            fieldLabel: 'Target Sprint',
            labelAlign: 'right',
            value: 'R4 Sprint 6',
            stateId: 'techservices.rally.validator.targetsprint',
            stateEvents: ['change'],
            stateful: true,
            allowNoEntry: false,
            width: '300'
        });
        cb.on('change', this.analyzeData,this);
    },
    
    //_addReleaseSelector: function(){
    //    this.logger.log('_addReleaseSelector');
    //    if (this.down('#cb-release')){
    //        this.down('#cb-release').destroy();
    //    }
    //
    //    var cb = this.getHeader().add({
    //        xtype: 'rallyreleasecombobox',
    //        itemId: 'cb-release',
    //        fieldLabel: 'Release',
    //        labelAlign: 'right',
    //        allowNoEntry: false,
    //        width: '300'
    //    });
    //    cb.on('change', this.gatherData,this);
    //},

    //getSelectedReleaseRecord: function(){
    //    if (this.down('#cb-release')){
    //        return this.down('#cb-release').getRecord();
    //    }
    //    return null;
    //},

    getSelectedTargetSprint: function(){
        if (this.down('#cb-targetsprint')){
            return this.down('#cb-targetsprint').getValue();
        }
        return null;
    },

    
    getHeader: function(){
        this.logger.log('getHeader');

        if (this.down('#ct-header')){
            return this.down('#ct-header');
        }

        return this.add({
            xtype: 'container',
            itemId: 'ct-header',
            layout: {type: 'hbox'},
            padding: 10
        });
    },

    getBody: function(){
        this.logger.log('getBody');

        if (this.down('#ct-body')){
            return this.down('#ct-body');
        }
        return this.add({
            xtype: 'container',
            itemId: 'ct-body'
        });
    },
    
    getSettingsFields: function () {
        var fields = [];


        fields.push({
            name: 'validCDS',
            xtype: 'rallyfieldvaluecombobox',
            model: this.portfolioItemFeature,
            fieldLabel: 'Valid Code Deployment Schedules',
            labelWidth: 300,
            labelAlign: 'right',
            width: 600,
            field: 'c_CodeDeploymentSchedule',
            multiSelect: true
        });

        fields.push({
            name: 'excludeProjects',
            xtype: 'rallymultiobjectpicker',
            labelWidth: 300,
            labelAlign: 'right',
            modelType: Ext.identityFn('Project'),
            margin: '10px 0 150px 0',
            fieldLabel: 'Exclude Projects'
        });

        
        return fields;
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        Ext.apply(this, settings);

        this.launch();
    }
});

Ext.define('Rally.technicalservices.FeatureValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',

    requiredFields: undefined,
    iterations: [],
    stories: [],
    targetSprint: null,
    featureRiskColors: [],
  //  featureHistoryByOid: null,
    currentRelease: null,
    validCDS: null,
    completedStates: ["Operate","Done"],
    featureRiskNames: ["High Risk", "Moderate Risk"],
    displayColorClassificationMapping: null,

    constructor: function(config){
        Ext.apply(this, config);
        this.requiredFields = ['Release','c_FeatureTargetSprint','c_FeatureDeploymentType','c_CodeDeploymentSchedule','State','DisplayColor','PlannedStartDate','PlannedEndDate'];
        //if (config.historicalFeatureSnapshots){
        //    this.featureHistoryByOid = this.aggregateSnapsByOidForModel(config.historicalFeatureSnapshots);
        //}
    },
    
    ruleFn_missingFieldsFeature: function(r) {
        var missingFields = [];

        _.each(this.requiredFields, function (f) {
            if (!r.get(f)) {
                missingFields.push(r.getField(f).displayName);
            }
        });
        if (missingFields.length === 0) {
            return null;
        }
        return Ext.String.format('Missing fields: {0}', missingFields.join(', '));
    },
    
    ruleFn_stateForTargetSprint: function(r) {
        if ( ! this.targetSprint ) {
            return null;
        }
        var featureDone = false;
        if (r.get('State') && r.get('State').Name){
            featureDone = Ext.Array.contains(this.completedStates, r.get('State').Name);
        }

        if (featureDone){
            return null;
        }
        var featureTargetSprint = r.get('c_FeatureTargetSprint');
        if ( Ext.isEmpty( featureTargetSprint) ) { return null; }
        
        if (featureTargetSprint < this.targetSprint ) {
            return Ext.String.format('Feature is set to TargetSprint ({0}) that is earlier than {1} but is not done',featureTargetSprint, this.targetSprint);
        }
        return null;
    },
    
    ruleFn_stateSynchronization: function(r) {
        /**
         * State == Done,
         * then all user stories should be accepted
         * AND
         * if All user stories == Accepted,
         * State should be Done
         */



        var featureDone = false ,
            storiesAccepted = r.get('AcceptedLeafStoryCount') === r.get('LeafStoryCount');

        if (r.get('State') && r.get('State').Name){
            featureDone = Ext.Array.contains(this.completedStates, r.get('State').Name);
        }

        if (featureDone === storiesAccepted){
            return null;
        }
        if (featureDone){
            return Ext.String.format('Feature is Done but not all stories are accepted ({0} of {1} accepted)', r.get('AcceptedLeafStoryCount'), r.get('LeafStoryCount'));
        }
        return Ext.String.format('Feature state ({0}) should be Done because all stories are accepted.', r.get('State').Name);
    },
    _getFeatureRiskColors: function(){
        var mapping = this.displayColorClassificationMapping || {},
            colors = [],
            risk_names = this.featureRiskNames;
        _.each(mapping, function(name, color){
            if (Ext.Array.contains(risk_names, name)){
                colors.push(color);
            }
        });
        return colors;
    },
    ruleFn_featureIsRisk: function(r){
        if (r.get('DisplayColor')){
            if (Ext.Array.contains(this._getFeatureRiskColors(), r.get('DisplayColor'))){
                return Ext.String.format('<div class="tscolor" style="background-color:{0};"></div>Feature is flagged as a Risk', r.get('DisplayColor'));
            }
        }
        return null;
    },
    //ruleFn_featureTargetSprintPushed: function(r){
    //    var featureHistory = this.featureHistoryByOid[r.get('ObjectID')],
    //        inRelease = false,
    //        startTargetSprint = null,
    //        endTargetSprint = null;
    //
    //    if (featureHistory) {
    //
    //        _.each(featureHistory, function (snap) {
    //            if (!inRelease && snap.Release.Name == this.currentRelease) {
    //                inRelease = true;
    //            }
    //            if (!startTargetSprint && snap['_PreviousValues.c_FeatureTargetSprint'] &&
    //                snap['_PreviousValues.c_FeatureTargetSprint'] != '' &&
    //                snap['_PreviousValues.c_FeatureTargetSprint'] != 'TBD') {
    //                startTargetSprint = snap['_PreviousValues.c_FeatureTargetSprint'];
    //            }
    //
    //            if (snap['c_FeatureTargetSprint']){
    //                endTargetSprint = snap['c_FeatureTargetSprint'];
    //            }
    //        });
    //
    //        if (startTargetSprint &&
    //            startTargetSprint != endTargetSprint) {
    //
    //            return Ext.String.format('Feature Target Sprint pushed from {0} to {1}',
    //                startTargetSprint, endTargetSprint);
    //        }
    //    }
    //    return null;
    //},
    ruleFn_validateCodeDeploymentSchedule: function(r){
        if (!this.validCDS || this.validCDS.length == 0){
            return null;
        }

        var featureDone = false;
        if (r.get('State') && r.get('State').Name){
            featureDone = Ext.Array.contains(this.completedStates, r.get('State').Name);
        }

        if (r.get('c_CodeDeploymentSchedule') && featureDone == false &&
            !Ext.Array.contains(this.validCDS, r.get('c_CodeDeploymentSchedule'))){
            return Ext.String.format('Code Deployment Schedule ({0}) is not a current valid Code Deployment Schedule.', r.get('c_CodeDeploymentSchedule'));
        }
        return null;
    },
//    ruleFn_featureTargetSprintMatchesRelease: function(r){
//        /**
//         * FTS == R4.xxx, then Release should be Release 4
//         *
//         */
//        var fts = r.get('c_FeatureTargetSprint'),
//            release = r.get('Release').Name;
//
//        var matches = release.match(/^Release\s+(\d+)/);
//        if (matches){
//            var re = new RegExp('^R' + matches[1]);
//            if (re.test(fts)){
//                return null;
//            }
//        }
//        return Ext.String.format('Feature Target Sprint ({0}) does not match Release ({1})',fts, release);
//
//    },
    ruleFn_featureHasDoDStories: function(r){



        return null;
    },
    ruleFn_storiesPlannedByFeatureTargetSprint: function(r){
        /**
         * FTS == R4.xxx,
         * then all US.Iteration should be scheduled in or before R4.xxx
         */
        return null;
    },
    ruleFn_featureDisplayColor: function(r){
        /**
         * DisplayColor should be one of the risk associated colors...
         */
        if (r.get('DisplayColor')){
            if (Ext.Array.contains(_.keys(this.displayColorClassificationMapping), r.get('DisplayColor').toLowerCase())){
                return null;
            }
            return Ext.String.format('DisplayColor (<span style="background-color:{0};">{0}</span>) is not a current valid Feature Risk Color.', r.get('DisplayColor'));
        }

        return Ext.String.format('DisplayColor <span style="background-color:{0};">{0}</span> is not set.', r.get('DisplayColor'));
    },
    aggregateSnapsByOidForModel: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID || snap.get('ObjectID');
                if (snaps_by_oid[oid] == undefined){
                    snaps_by_oid[oid] = [];
                }
                snaps_by_oid[oid].push(snap.getData());
        });
        return snaps_by_oid;
    }
});

Ext.define('Rally.technicalservices.UserStoryValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',

    requiredFields: undefined, //
    iterations: [],

    constructor: function(config){
        Ext.apply(this, config);
        this.requiredFields = ['Owner','Feature'];
    },
    ruleFn_unscheduledIterationScheduleState: function(r){
        /**
         * If Iteration = unscheduled and state In-Progress raise flag
         */
        if (!r.get('Iteration') && r.get('ScheduleState') != 'Defined'){
            return Ext.String.format('{0} is an invalid state for an unscheduled Iteration', r.get('ScheduleState'));
        }
        return null;
    },
    
    ruleFn_missingFieldsStory: function(r) {
        var missingFields = [];

        _.each(this.requiredFields, function (f) {
            if (!r.get(f)) {
                missingFields.push(r.getField(f).displayName);
            }
        });
        if (missingFields.length === 0) {
            return null;
        }
        return Ext.String.format('Missing fields: {0}', missingFields.join(', '));
    },
    
    ruleFn_blockedFieldsPopulated: function(r){
        /**
         * Story is blocked and Blocker Category != null, Blocker Creation Date != null,
         * blocker Owner != null, blockerState != null
         */
        var requiredBlockerFields = ['c_BlockerCategory','c_BlockerOwnerFirstLast','c_BlockerState'],
            missingFields = [];
        if (r.get('Blocked')){

            _.each(requiredBlockerFields, function (f) {
                if (!r.get(f)) {
                    missingFields.push(r.getField(f).displayName);
                }
            });
            if (missingFields.length > 0){
                return Ext.String.format('Missing required fields for a blocked story:  {0}', missingFields.join(','));
            }
        }
        return null;
    },
    ruleFn_blockedNotInProgress: function(r){
        /**
         * Story is blocked, schedulestate must be In-Progress
         */
        if (r.get('Blocked')){
            if (r.get('ScheduleState') != 'In-Progress'){
                return Ext.String.format('Invalid State ({0}) for blocked story', r.get('ScheduleState'));
            }
        }
        return null;
    },
    ruleFn_sprintCompleteNotAccepted: function(r){
        /**
         * If sprint is in the past, then the story must be Completed or Accepted
         */
        var msg = null;
        if (r.get('Iteration') && r.get('ScheduleState') != 'Accepted'){
            var iteration_ref = r.get('Iteration')._ref;
            Ext.Array.each(this.iterations, function(i){
                if (i.get('_ref') == iteration_ref){
                    if (Rally.util.DateTime.fromIsoString(i.get('EndDate')) < new Date()){
                        msg = Ext.String.format("Story not Accepted after Iteration {0} has ended.", i.get('Name'));
                    }
                    return false;
                }
            });

        }
        return msg;
    }
});


            
               Rally.launchApp('ts-data-validation', {
                   name: 'Data Validation'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.pretty-grid {
    border-style: solid;
    border-width: 1px;
    border-color: #e0e0e0;

}
.rally-grid {
    border-bottom: 0;
}
.tscolor {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    text-align: center;
    color: white;
    border-style: solid;
    border-width: 1px;
    display: inline-block;
}
    </style>

</head>
<body></body>
</html>